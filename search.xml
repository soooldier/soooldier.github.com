<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Anacron理解及探究]]></title>
      <url>%2F2017%2F04%2F01%2FAnacron%E7%90%86%E8%A7%A3%E5%8F%8A%E6%8E%A2%E7%A9%B6%2F</url>
      <content type="text"><![CDATA[在linux中，有三种用于任务调度的工具 at, cron, anacron ；在实际开发中，最常见的就是使用 cron 去调度执行业务的程序。但是对于 at 和 anacron 的使用场景却很少涉猎。其中 at 一般只用来处理“一次”的任务所以它更少会被用到，本文不会说它；而 anacron 却在某些场景能解决我们的关键问题，现在有这样一个需求：“每天凌晨统计一下前一天的订单量”通常的做法就是写一个计划任务每天凌晨去执行统计脚本 15 * * * * /usr/local/php/bin/php -f your_script_path/order_statistic.php是不是so easy？如果这么想，那么年轻人，你还是too young too simple！试想一下，如果机房在00:10到00:20断电怎么办？ Anacron能做什么手册上提到，“Anacron以天为单位周期性地执行命令” 。单从这里看似乎和 cron 的功能一样，只不过 anacron 是以天为单位，而 cron 最小执行的周期是分钟。其实不然，cron 和 anacron 是两种完全不相干的任务调度工具（虽然它们可以结合使用）： cron 是通过daemon程序 crond 来运行任务；而 anacron 则没有任何daemon程序，它所对应的 anacron 进程运行完毕就退出。 cron 在执行任务时不做任何跟时间相关记录；而 anacron 会记录下任务完成的时间，这样就给本应该执行却没有执行的任务再执行的条件和机会。 anacron 本身也可以用 cron 去调度。 因此，anacron 可以解决前面提到因为机房断电造成任务无法执行的问题。在实际应用中它和 cron 相互独立却又互为补充。 Anacron如何使用/etc/anacrontab 是 anacron 的配置文件，在配置 anacron 任务的时候主要注意4个部分的配置： period in days 执行周期；最小1天，也可以3天，5天，一个星期（7天）乃至一个月（月份不能确定有多少天，所以用@monthly代替）。 delay in minutes 延迟多长时间执行，以分钟为单位。为了避免多个任务在同一时间执行而造成服务器繁忙，所以应该错峰执行。当然真正延迟的时间还要考虑 RANDOM_DELAY 的配置。 job-identifier 任务的唯一标识。它用来创建文件记录任务执行的时间，通常创建在 /var/spool/anacron/ 目录中。 command 真正执行的命令。 订单统计的例子对于前面提到的订单量统计的问题，则可以这么配置： 1234567891011# /etc/anacrontab: configuration file for anacron# See anacron(8) and anacrontab(5) for details.SHELL=/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# the maximal random delay added to the base delay of the jobsRANDOM_DELAY=5# the jobs will be started during the following hours onlySTART_HOURS_RANGE=1-24#period in days delay in minutes job-identifier command1 5 cron.daily.order.statistic /usr/local/php/bin/php -f your_script_path/order_statistic.php 由于 anacron 本身是一个普通的程序，还需 cron 去调度执行。 12# 每个小时去执行anacron01 * * * * /usr/sbin/anacron centos(6.8)中的例子Linux中有一个日志处理程序 logrotate，它每天运行一次来进行各种日志文件的归档压缩。下面几个文件就能很好地说明日志处理的流程： /etc/cron.d/0hourly：cron 调度，每小时执行一次 12345SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootHOME=/01 * * * * root run-parts /etc/cron.hourly /etc/cron.hourly/0anacron：触发执行 anacron 1234567891011121314151617#!/bin/bash# Skip excecution unless the date has changed from the previous runif test -r /var/spool/anacron/cron.daily; then day=`cat /var/spool/anacron/cron.daily`fiif [ `date +%Y%m%d` = &quot;$day&quot; ]; then exit 0;fi# Skip excecution unless AC poweredif test -x /usr/bin/on_ac_power; then /usr/bin/on_ac_power &amp;&gt; /dev/null if test $? -eq 1; then exit 0 fifi/usr/sbin/anacron -s /etc/anacrontab：执行 /etc/cron.daily 目录下的任务 12345678910111213141516# /etc/anacrontab: configuration file for anacron# See anacron(8) and anacrontab(5) for details.SHELL=/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# the maximal random delay added to the base delay of the jobsRANDOM_DELAY=45# the jobs will be started during the following hours onlySTART_HOURS_RANGE=3-22#period in days delay in minutes job-identifier command1 5 cron.daily nice run-parts /etc/cron.daily7 25 cron.weekly nice run-parts /etc/cron.weekly@monthly 45 cron.monthly nice run-parts /etc/cron.monthly /etc/cron.daily/logrotate：logrotate 任务最终被触发 1234567#!/bin/sh/usr/sbin/logrotate /etc/logrotate.confEXITVALUE=$?if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;fiexit 0 Anacron是怎做到的anacron 能做到任务“不错过”的关键点在于它每执行完一次便记录完成的时间。anacron 进程执行任务的时候先通过文件里的上次完成时间和其它的配置判断能否执行，如果能执行则创建一个新的进程执行，当前进程退出；如不能执行则直接退出。详细的过程可通过 strace -f /usr/sbin/anacron 看到。 Anacron如何测试我们在测试 anacron 的时候通常希望忽略配置文件中延迟执行的时间。可以使用 -n 参数来实现 /usr/sbin/anacron -n your_job_identifier，而 -f 参数则可以忽略对timestamp文件的检测。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx错误502，503，504分析]]></title>
      <url>%2F2017%2F02%2F10%2Fnginx%E9%94%99%E8%AF%AF502%EF%BC%8C503%EF%BC%8C504%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[开发过程中我们经常会遇到nginx 502，503，504错误，这些错误代表什么？什么情况下会出现这些错？下面一一说明（均以nignx+php-fpm举例）： wikipedia上这么解释：502 Bad Gateway The server was acting as a gateway or proxy and received an invalid response from the upstream server.503 Service Unavailable The server is currently unavailable (because it is overloaded or down for maintenance). Generally, this is a temporary state.504 Gateway Time-out The server was acting as a gateway or proxy and did not receive a timely response from the upstream server. 502 Bad Gatewayfpm进程挂掉或者后端程序过长时间未返回。编写一个简单的php脚本gateway.php进行测试，内容很简单 &lt;?php sleep(10);echo ‘ok;’?&gt; ，开始下面的测试： 启动nginx，不启动fpm，直接 curl http://localhost/gateway.php ，响应502 bad gateway错误且nginx的error log出现错误 12017/02/10 19:08:21 [error] 216#216: *84 connect() failed (111: Connection refused) while connecting to upstream, client: 172.17.0.1, server: website80.com, request: &quot;GET /gateway.php HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;localhost&quot; 启动fpm，修改php-fpm.conf中request_terminate_timeout的值为5s。继续 curl http://localhost/gateway.php ，响应502 bad gateway。nginx和php-fpm分别报错 123456// nginx error log2017/02/10 19:10:57 [error] 246#246: *88 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 172.17.0.1, server: website80.com, request: &quot;GET /gateway.php HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;localhost&quot;// php-fpm error log[10-Feb-2017 19:10:57] WARNING: [pool www] child 242, script &apos;/home/website/default/gateway.php&apos; (request: &quot;GET /gateway.php&quot;) execution timed out (6.205572 sec), terminating[10-Feb-2017 19:10:57] WARNING: [pool www] child 242 exited on signal 15 (SIGTERM) after 36.692467 seconds from start 503 Service Unavailable当遇到这个状态码的时候表示服务临时不可用，比如nginx配置了频率限制而client端又超过了配置的限制后就会收到503的响应。 504 Gateway Time-outnginx的fastcgi模块有一个fastcgi_read_timeout配置，它表示从FastCGI server获取数据的超时时间。如果超过这个配置客户端就是收到504的响应。还以 gateway.php 举例（修改fastcgi_read_timeout的值为5s）：12// nginx error log2017/02/12 14:57:26 [error] 138#138: *1113 upstream timed out (110: Connection timed out) while reading response header from upstream, client: 172.17.0.1, server: website80.com, request: &quot;GET /gateway.php HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;localhost&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记一次lnmp环境问题]]></title>
      <url>%2F2016%2F09%2F08%2F%E8%AE%B0%E4%B8%80%E6%AC%A1lnmp%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[起因本打算把公司内部的php升级为5.6.x，op給了一个测试环境。于是便开始了环境搭建并测试的工作，configure，make，make install。正当我使用phpinfo()测试通过天真地以为环境搭建完成的时候，突然发现了一个奇怪的问题：通过fpm访问php的错误日志并未纪录在php.ini指定的日志文件中而却出现在了php-fpm.conf指定的配置文件。 问题复现php.ini中跟错误记录相关的配置如下： 123error_reporting = E_ALLlog_errors = Onerror_log = /home/ziroom/runtime/php/var/log/php-errors.log php-fpm.conf的配置： 1234error_log = /home/ziroom/runtime/php/var/log/php-fpm.loglog_level = notice; Redirect worker stdout and stderr into main error log. If not set, stdout and stderr will be redirected to /dev/null according to FastCGI specs. Note: on highloaded environement, this can cause some delay in the page process time (several ms).catch_workers_output = yes 注意fpm中的catch_workers_output设置，它的作用是把fpm worker进程的stdout和stderr转发到主进程的error log。一定设置它为yes！！！ 访问测试脚本test.php，它的内容为echo 2/0;，php-fpm.log中的日志内容如下： 1[08-Sep-2016 14:29:41] WARNING: [pool www] child 126 said into stderr: &quot;NOTICE: PHP message: PHP Warning: Division by zero in /usr/local/nginx/html/index.php on line 2&quot; 问题排查从上面的日志可以看出pid为126的进程（fpm子进程）向stderr发送了一条级别为NOTICE的错误信息，这条错误信息恰好是php抛出的一个Warning；但是对于真正记录错误日志的fpm主进程来说却又是一个WARNING。 接下来试着调高fpm的log_level为warning，重新访问test.php。结果并没有记录任何错误日志。这个现象很容易解释，fpm子进程向stderr传递的是一个NOTICE级别的信息，而配置文件中log_level的设置高于NOTICE，因而不会记录日志。 但是！！！为何php的错误会记录到fpm的日志文件中？请叫老b得知他没有这个问题，那么一定我自己的问题了。几经辗转后超哥提醒我：看看是不是权限的问题！ 刚开始其实我是拒绝的，因为按常理来说如果是因为权限问题的话在日志文件里应该会有报错的。苦于没有别的办法就看了下目录权限，卧槽！！！真是有问题，fpm的用户和组都是ziroom，而配置的/home/ziroom/runtime/php/var/log/php-errors.log对ziroom用户来说却没有写入权限。修改权限后重启fpm，访问test.php，一切正常，错误日志写到了php-errors.log中。 追根溯源问题虽然解决了，但是并未解决掉心里的疑问，打算再追查下去。疑问有2 ： 没有权限为什么没有报错 写入php-errors.log没有权限，为何写入php-fpm.log却有权限 对于问题1，root用户启动php-fpm主进程，主进程fork子进程，它的用户被设置成了fpm。于是把fpm的子进程数量改为1，strace该进程看到以下信息： docker环境直接使用strace会报错（strace: attach: ptrace(PTRACE_ATTACH, …): Operation not permitted）必须打开选项–privileged 1234567891011121314151617181920212223...open(&quot;/usr/local/nginx/html/index.php&quot;, O_RDONLY) = 5fstat(5, &#123;st_mode=S_IFREG|0644, st_size=16, ...&#125;) = 0fstat(5, &#123;st_mode=S_IFREG|0644, st_size=16, ...&#125;) = 0fstat(5, &#123;st_mode=S_IFREG|0644, st_size=16, ...&#125;) = 0mmap(NULL, 16, PROT_READ, MAP_SHARED, 5, 0) = 0x7f8aa96dd000getcwd(&quot;/&quot;, 4095) = 2chdir(&quot;/usr/local/nginx/html&quot;) = 0setitimer(ITIMER_PROF, &#123;it_interval=&#123;0, 0&#125;, it_value=&#123;30, 0&#125;&#125;, NULL) = 0munmap(0x7f8aa96dd000, 16) = 0close(5) = 0open(&quot;/usr/local/php/var/log/php_errors.log&quot;, O_WRONLY|O_CREAT|O_APPEND, 0644) = -1 EACCES (Permission denied)write(2, &quot;NOTICE: PHP message: PHP Warning&quot;..., 97) = 97chdir(&quot;/&quot;) = 0times(&#123;tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0&#125;) = 4296910449stat(&quot;/etc/localtime&quot;, &#123;st_mode=S_IFREG|0644, st_size=118, ...&#125;) = 0write(4, &quot;127.0.0.1 - 09/Sep/2016:01:59:5&quot;..., 110) = 110setitimer(ITIMER_PROF, &#123;it_interval=&#123;0, 0&#125;, it_value=&#123;0, 0&#125;&#125;, NULL) = 0write(3, &quot;\1\7\0\1\0Y\7\0PHP message: PHP Warning&quot;..., 200) = 200shutdown(3, SHUT_WR) = 0recvfrom(3, &quot;\1\5\0\1\0\0\0\0&quot;, 8, 0, NULL, NULL) = 8recvfrom(3, &quot;&quot;, 8, 0, NULL, NULL) = 0close(3) 可以看到通过strace拿到的信息中出现了Permission denied关键字，紧接着把”NOTICE: PHP message: PHP Warning”字符串写到了标准错误输出。这就和第一次在php-fpm日志中看到的信息相符了。 问题2，fpm主进程是以root用户启动的，那么大胆猜测一下php-fpm.log只有fpm主进程才往日志里添加内容。lsof看一下： 123$ lsof /usr/local/php/var/log/php-fpm.log$ php-fpm 125 root 2w REG 0,46 1967 607 /usr/local/php/var/log/php-fpm.log$ php-fpm 125 root 3w REG 0,46 1967 607 /usr/local/php/var/log/php-fpm.log 果不其然，只有fpm的主进程（pid为125）才向php-fpm.log文件中写入日志。 总结至此，忽略内部更详尽细节，已经完全解决了文章开头的疑问。至于fpm为何这么设计，我等菜鸟无法评论。 最后感谢老b同志亲临现场指导，虽是由一个低级错误引起，但只需要稍微往深一点研究还是挺有意思的。]]></content>
    </entry>

    
  
  
</search>
